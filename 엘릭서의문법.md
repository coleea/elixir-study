엘릭서 창시자는 루비온레일즈 개발자였다\
즉 루비 개발자였다\
이말은 엘릭서 창시자가 루비같은 언어를 좋아한다는 뜻이다\
루비같은 언어란 간결하고 표현력이 높은 언어를 말한다. 파이썬같은 언어를 떠올려도 좋다\
이처럼 간결하고 표현력이 높은 언어를 좋아하는 사람이 만든 언어가 엘릭서이다\
따라서 엘릭서도 간결하고 표현력이 높을 수밖에 없다. 만든 사람이 이런 특징을 원했으니까.

##### 변수할당
변수 할당시에 var 등의 명시를 할 필요가 없다\
루비나 파이썬과 똑같다\
예)
```
a = "변수할당중"
```
위의 코드는 a를 미리 선언하지 않은 상태에도 유효하다

##### 각각할당
루비의 각각할당 기능도 똑같이 제공한다\
다음은 정상 작동한다
```
iex(11)> [a, b] = ["1st assign", "2nd assign"]
["1st assign", "2nd assign"]
iex(12)> a
"1st assign"
iex(13)> b
"2nd assign"
```
루비에서는 각각할당시에 괄호를 쓰지 않는다. 그 점만 제외하면 기능적으로는 완전히 같다\
만일 엘릭서에서 각각할당시에 괄호를 쓰지 않으면 아래와 같다
```
iex(6)> a, b = 1, 2
** (SyntaxError) iex:6:2: syntax error before: ','
```
##### 각각할당에서의 플래튼(flatten)
각각할당시에 다음처럼 중첩된 리스트를 할당해보자
```
iex(1)> [a, [b,c]] = [1, [2,3]]
[1, [2, 3]]
```
할당받는 변수도 리스트이고 할당하는 값도 리스트라면 리스트내에 중첩된 리스트는 플래튼(flatten)된다. 즉 다음과 같이 변한다
`[a, b,c] = [1, 2,3]`
그러나 할당받는 변수가 중첩 리스트가 아닌 경우에는 에러를 발생한다
```
iex(2)> [a, b,c] = [1, [2,3]]  
** (MatchError) no match of right hand side value: [1, [2, 3]]
```
즉 할당할 때 포멧을 엄격하게 지킨다

##### i 커맨드
변수의 정보를 출력한다\
예)
```
iex(1)> x = 5
5
iex(2)> i x
Term
  5
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, List.Chars, String.Chars
```

##### 문자열 concat 명령어 : <>
엘릭서는 문자열을 합병할 때 `+` 연산자를 쓰지 않는다. 대신 `<>` 연산자를 사용한다\
예)
```
iex(4)> "나는 첫번째 문자열" <> " 그리고 나는 두번째 문자열"
"나는 첫번째 문자열 그리고 나는 두번째 문자열"
```
왜 다른 언어처럼 더하기(`+`)로 문자열 합병을 할 수 없을까?\
원래 덧셈기호는 수와 수를 피연산자로 받아서 계산하는 연산자이기 때문이다\
문자열과 문자열을 `+`연산한다는 개념은 논리적으로 말이 되지 않는다\
그래서 하스켈같은 언어도 문자열간에 `+` 연산을 수행하면 에러를 던진다

##### atom
아톰은 루비의 심볼과 문법적으로 똑같고 기능적으로도 똑같다
`:문자열` 과 같은 방식으료 표기한다\
`:"문자열"` 과 같은 방식으료 표기할 수도 있다\
아톰은 변수에 할당할 필요가 없이 쓸 수 있다\

##### 튜플
`{1,2,3}`과 같은 꺽쇠 괄호로 표기된다


##### 파일 읽기
파일관련 기능은 File모듈이 제공한다
```
iex(6)> File.read("./readme.md")
{:ok, "i am readme.md file"}
```
File모듈을 IO모듈과 혼동하지 말것\
유저에게 입력을 받을때는 IO모듈을 사용한다


##### 부울값 (true & false)
다음은 참이다
```
iex(9)> :false == false
true
```
왜냐? true와 false는 애초부터 데이터 타입이 아톰이기 때문이다\
반면 `:false == false` 는 루비에서는 false이다\
루비에서 true와 false는 심볼이 아니기 때문이다


##### 모듈 및 함수정의
defmodule 키워드로 모듈을 정의한다\
모듈 내부에서 def 키워드로 함수를 정의한다\
예를들어 아래와 같다
```
defmodule Modules do
    def main do
        name = IO.gets('이름을 입력하시오')
    end
end
```
정의한 모듈은 REPL 명령어인 iex(interactive elixir shell)에서 불러올 수 있다\
참고로 루비의 REPL 명령어는 irb(interactive ruby shell)이다\
REPL 명령어까지 거의 똑같은 것이 보이는가
```
c('내가정의한모듈의경로')
```
위에서 c는 컴파일의 약자이고 말그대로 파일에서 모듈을 찾아 해당 모듈을 컴파일한다\
모듈을 컴파일하면 모듈내에 정의된 함수를 호출할 수 있다\
함수를 호출할 때는 `모듈이름.함수명()`과 같은 식으로 호출한다\
인자를 넣지않은 경우에는 괄호를 생략하고 `모듈이름.함수명`과 같은 방식으로도 호출할 수 있다
```
Interactive Elixir (1.12.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> c("hello_world.ex")
[Modules]
iex(2)> Modules.main
이름?이아무개        
"이아무개\n"
iex(3)> Modules.main()
이름?steven suzuki
"steven suzuki\n"
````
여기에 임의의 인자를 넣어서 호출해 보자
```
iex(5)> Modules.main("i am not used string")
** (UndefinedFunctionError) function Modules.main/1 is undefined or private. Did you mean one of:

      * main/0

    Modules.main("i am not used string")
```
에러가 발생했다. 에러문에서 `function Modules.main/1 is undefined or private`라는 메시지는 인자가 1개인 main함수가 정의되어 있지 않다는 뜻이다. 즉 엘릭서는 가변인자를 지원하지 않는다. js를 사용하던 사람이라면 이점이 조금 어색할 수 있다

##### 맵 (map)
엘릭서의 맵은 문법이 특이하다. 파이썬의 dict나 js의 객체처럼 `{"key" : "value"}`와 같은 방식이 아니다. `:` 대신 `=>` 로 표기한다. 그러나 `{"key"=>"value"}`는 문법적으로 오류다
```
iex(11)> {"key"=>"value"} 
** (SyntaxError) iex:11:7: syntax error before: '=>'
```
왜인가? `{ }`을 쓰는 자료구조는 튜플이다. 그래서 까다롭게도 튜플과의 구분을 위해 앞에 퍼센트(`%`) 기호를 붙여줘야 한다.
```
iex(13)> %{"key"=>"value"}
%{"key" => "value"}
```
이제 에러를 내뿜지 않는다. 헷갈리지 마라. 이건 람다함수 표기법이 아니라 맵이다\
재미있게도 엘릭서는 맵 끼리도 할당이 된다. 이게 무슨 말인가? 이건 리스트의 각각할당과 원리가 똑같다
```
iex(14)> %{"key"=>variable} = %{"key"=>"asdf"}
%{"key" => "asdf"}
iex(15)> variable
"asdf"
```
위에서는 map의 variable 변수에 "asdf가 할당되었다". 이게 가능한 이유는 할당하는 쪽과 할당받는 쪽 모두 자료구조의 포멧이 똑같이 때문이다\
그러나 포멧은 똑같은데 key가 다르다면? 이 경우도 할당하는게 맞다고 생각하는가?
```
iex(16)> %{"key"=>variable} = %{"another key"=>"asdf"}
** (MatchError) no match of right hand side value: %{"another key" => "asdf"}
```
보는것처럼 key가 다른 맵끼리 할당하려고 하면 에러를 던진다. 어찌보면 이는 합리적인 처사라고 볼수있다. 왜냐? 그저 키가 달라도 할당할 수 있도록 프로그램을 설계했다고 가정해 보자.\
그런 경우에는 map에 원소가 하나가 아니라 둘인 경우에 어느 값을 어느 변수에 할당해야 할지 결정할 수 없다
```
iex(17)> %{"key1"=>v1, "key2"=>v2} = %{"key2"=>"key2value", "key1"=> "key1value"}
%{"key1" => "key1value", "key2" => "key2value"}
iex(18)> v1
"key1value"
iex(19)> v2
"key2value"
```
위의 예에는 2개의 키인 key1과 key2가 있다. 그런데 할당하는 쪽에서 key2와 key1의 순서를 뒤바꿨다. 이 경우 그저 key값이 어떤지에 상관없이 순서대로 할당한다고 가정하면 v1에 "key2value"가 할당되고 v2에 "key1value"가 할당된다. 이런 할당을 원하는 개발자는 거의 없을 것이다\
마지막으로 맵끼리의 할당시에는 맵을 구성하는 키가 완벽하게 동일할 필요는 없다. 할당받는 쪽이 할당하는 맵의 부분집합이기만 하면 된다. 즉 아래와 같은 상황이다
```
iex(20)> %{"key1"=>v1} = %{"key1"=>"1", "key2"=> "2"}                                
%{"key1" => "1", "key2" => "2"}
iex(21)> v1   
"1"
```
