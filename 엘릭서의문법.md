엘릭서 창시자 호세 발림은 원래 루비온레일즈 개발자였다\
즉 루비 개발자였다\
이말은 엘릭서 창시자가 루비같은 언어를 좋아한다는 뜻이다\
루비같은 언어란 간결하고 표현력이 높은 언어를 말한다. 파이썬같은 언어를 떠올려도 좋다\
이처럼 간결하고 표현력이 높은 언어를 좋아하는 사람이 만든 언어가 엘릭서이다\
따라서 엘릭서도 간결하고 표현력이 높을 수밖에 없다. 만든 사람이 이런 특징을 원했으니까.

##### 변수할당
변수 할당시에 var 등의 명시를 할 필요가 없다\
루비나 파이썬과 똑같다\
예)
```
a = "변수할당중"
```
위의 코드는 a를 미리 선언하지 않은 상태에도 유효하다\
그리고 엘릭서는 (유감이지만) 같은 변수에 재할당도 가능하다. 즉 아래 코드는 유효하다
```
iex(4)> a = "처음 할당" 
"처음 할당"
iex(5)> a = "재할당"
"재할당"
```
재할당이 되는건 당연한게 아니냐고 반문할 수도 있다. 그러나 엘릭서의 전신인 얼랭(erlang)는 재할당이 불가능하다. 즉 위의 코드는 에러를 던진다\
사실 재할당을 금하는 건 함수형 프로그래밍에서는 그리 신기한 규칙도 아니며 오히려 일반적인 경우이다. 엘릭서의 전신인 얼랭의 창시자 조 암스트롱은 `변수를 변경할 수 없다는 사실은 지극히 중요하다`고 까지 말했다. 그것은 조 암스트롱이 함수형 프로그래밍의 열열한 지지자였고 그가 만든 얼랭도 함수형 언어였기 때문이다. 그런 함수형 언어는 데이터를 불변으로 다루는 코딩스타일을 선호한다. 하지만 엘릭서가 재할당이 되는 걸로 보아서 호세 발림은 이 말에 동의하지 않는 모양이다


##### 각각할당
엘릭서는 루비의 각각할당 기능도 제공한다\
다음은 정상 작동한다
```
iex(11)> [a, b] = ["1st assign", "2nd assign"]
["1st assign", "2nd assign"]
iex(12)> a
"1st assign"
iex(13)> b
"2nd assign"
```
루비에서는 각각할당시에 괄호를 쓰지 않는다. 그 점만 제외하면 기능적으로는 완전히 같다\
만일 엘릭서에서 각각할당시에 괄호를 쓰지 않으면 아래와 같다
```
iex(6)> a, b = 1, 2
** (SyntaxError) iex:6:2: syntax error before: ','
```
##### 각각할당에서의 플래튼(flatten)
각각할당시에 다음처럼 중첩된 리스트를 할당해보자
```
iex(1)> [a, [b,c]] = [1, [2,3]]
[1, [2, 3]]
```
할당받는 변수도 리스트이고 할당하는 값도 리스트라면 리스트내에 중첩된 리스트는 플래튼(flatten)된다. 즉 다음과 같이 변한다
`[a, b,c] = [1, 2,3]`
그러나 할당받는 변수가 중첩 리스트가 아닌 경우에는 에러를 발생한다
```
iex(2)> [a, b,c] = [1, [2,3]]  
** (MatchError) no match of right hand side value: [1, [2, 3]]
```
즉 할당할 때 포멧을 엄격하게 지킨다

##### i 커맨드
변수의 정보를 출력한다\
예)
```
iex(1)> x = 5
5
iex(2)> i x
Term
  5
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, List.Chars, String.Chars
```

##### 문자열 concat 명령어 : <>
엘릭서는 문자열을 합병할 때 `+` 연산자를 쓰지 않는다. 대신 `<>` 연산자를 사용한다\
예)
```
iex(4)> "나는 첫번째 문자열" <> " 그리고 나는 두번째 문자열"
"나는 첫번째 문자열 그리고 나는 두번째 문자열"
```
왜 다른 언어처럼 더하기(`+`)로 문자열 합병을 할 수 없을까?\
원래 덧셈기호는 수와 수를 피연산자로 받아서 계산하는 연산자이기 때문이다\
문자열과 문자열을 `+`연산한다는 개념은 논리적으로 말이 되지 않는다\
그래서 하스켈같은 언어도 문자열간에 `+` 연산을 수행하면 에러를 던진다

##### atom
아톰은 루비의 심볼과 문법적으로 똑같고 기능적으로도 똑같다
`:문자열` 과 같은 방식으료 표기한다\
`:"문자열"` 과 같은 방식으료 표기할 수도 있다\
아톰은 변수에 할당할 필요가 없이 바로 쓸 수 있다는 장점이 있다\

##### 튜플
`{1,2,3}`과 같은 꺽쇠 괄호로 표기된다


##### 파일 읽기
파일관련 기능은 File모듈이 제공한다
```
iex(6)> File.read("./readme.md")
{:ok, "i am readme.md file"}
```
File모듈을 IO모듈과 혼동하지 말것\
유저에게 입력을 받을때는 IO모듈을 사용한다


##### 부울값 (true & false)
다음은 참이다
```
iex(9)> :false == false
true
```
왜냐? true와 false는 애초부터 데이터 타입이 아톰이기 때문이다\
반면 `:false == false` 는 루비에서는 false이다\
루비에서 true와 false는 심볼이 아니기 때문이다


##### 모듈 및 함수정의
`defmodule`(define module의 준말) 키워드로 모듈을 정의한다. 아래 예제를 참조해보자

```
defmodule Modules do
    def main do
        name = IO.gets('이름을 입력하시오')
    end
end
```
defmodule 키워드에 이어서 모듈 이름을 정의하고 do와 end로 코드블럭을 감싼다. do와 end가 조금 어색하다고 생각할 수도 있는데 이건 c나 자바의 꺽쇠괄호(`{}`)와 기능적으로 똑같다.\
모듈을 정의했으면 모듈 내부에서 함수를 정의할 수 있다. 함수는 def 키워드로 정의한다. 이것은 루비의 함수 정의 키워드와 같다. 루비에서 괄호 대신에 do와 end로 코드블럭을 표현하는 모양까지 똑같다. 왜 꺽쇠괄호 `{}`로 블럭을 표현하지 않느냐고 반문할 수도 있지만 함수형 개발자들은 꺽쇠괄호를 촌스럽다고 생각하는 모양이다. 사실 이 두가지 표현법 사이에 의미적인 차이는 전혀 없다고 볼수있고 그저 취향의 문제라고 간주해도 좋다\
\
정의한 모듈은 REPL 명령어인 iex(interactive elixir shell)에서 불러올 수 있다\
참고로 루비의 REPL 명령어는 irb(interactive ruby shell)이다\
REPL 명령어까지 거의 똑같은 것이 보이는가
```
c('내가정의한모듈의경로')
```
위에서 c는 컴파일의 약자이고 말그대로 파일에서 모듈을 찾아 해당 모듈을 컴파일한다\
모듈을 컴파일하면 모듈내에 정의된 함수를 호출할 수 있다\
함수를 호출할 때는 `모듈이름.함수명(인자)`과 같은 식으로 호출한다. 
```
Interactive Elixir (1.12.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> c("hello_world.ex")
[Modules]
iex(2)> Modules.main
이름?이아무개        
"이아무개\n"
iex(3)> Modules.main()
이름?steven suzuki
"steven suzuki\n"
````
여기에 임의의 인자를 넣어서 호출해 보자
```
iex(5)> Modules.main("i am not used string")
** (UndefinedFunctionError) function Modules.main/1 is undefined or private. Did you mean one of:

      * main/0

    Modules.main("i am not used string")
```
에러가 발생했다. 에러문에서 `function Modules.main/1 is undefined or private`라는 메시지는 인자가 1개인 main함수가 정의되어 있지 않다는 뜻이다. 즉 엘릭서는 가변인자를 지원하지 않는다. js를 사용하던 사람이라면 이점이 조금 어색할 수 있지만 인자의 갯수를 엄격하게 따지는데는 이유가 있다. 그것은 패턴매칭 때문인데 이는 나중에 살펴보기로 한다\
\
한편 괄호안에 인자를 넣어 호출하는 방식은 다들 익숙할 것이다. 그러나 본인이 이전에 말했듯이 함수형 개발자들은 괄호를 촌스럽다고 생각한다. 그래서 엘릭서는 괄호를 피할 수 있는 방법도 제공한다
1. 인자가 없는 경우 : 이 경우는 괄호를 생략하고 `모듈이름.함수명`과 같은 방식으로도 호출할 수 있다. 이것은 괄호를 타이핑하지 않아도 되므로 더 합리적인 방법이라고 생각할 수 있다. 그러나 사람에 따라서는 이것이 함수를 호출한 것인지 직관적으로 이해하기 어렵다고 생각할 수 있다. 그러므로 괄호를 표기하던 표기 안하던 취향에 따라서 선택하면 된다
1. 인자가 있는 경우 : 이 경우에도 괄호를 생략하고 표기할 수 있다 가령 아래와 같은 트림함수가 있다고 해보자
```
iex(7)> String.trim("   i have trim space   ")                        
"i have trim space"
```
위의 예제에서 괄호를 제거한 채 인자를 그냥 옆에 써줘도 정상 작동한다
```
iex(8)> String.trim "  i have trim space  "   
"i have trim space"
```
괄호안에 인자를 넣을지 괄호를 제거할지는 선택 사항이다. 원하는 취향대로 코딩하면 된다

##### 맵 (map)
엘릭서의 맵은 문법이 특이하다. 파이썬의 dict나 js의 객체처럼 `{"key" : "value"}`와 같은 방식이 아니다. `:` 대신 `=>` 로 표기한다. 그러나 `{"key"=>"value"}`는 문법적으로 오류다
```
iex(11)> {"key"=>"value"} 
** (SyntaxError) iex:11:7: syntax error before: '=>'
```
왜인가? 꺽쇠괄호(`{ }`)을 쓰는 자료구조는 튜플이다. 그래서 까다롭게도 튜플과의 구분을 위해 앞에 퍼센트(`%`) 기호를 붙여줘야 한다.
```
iex(13)> %{"key"=>"value"}
%{"key" => "value"}
```
이제 에러를 내뿜지 않는다. 헷갈리지 마라. 이건 람다함수 표기법이 아니라 맵이다\
재미있게도 엘릭서는 맵 끼리도 할당이 된다. 이게 무슨 말인가? 이건 리스트의 각각할당과 원리가 똑같다
```
iex(14)> %{"key"=>variable} = %{"key"=>"asdf"}
%{"key" => "asdf"}
iex(15)> variable
"asdf"
```
위에서는 map의 variable 변수에 "asdf가 할당되었다". 이게 가능한 이유는 할당하는 쪽과 할당받는 쪽 모두 자료구조의 포멧이 똑같이 때문이다\
그러나 포멧은 똑같은데 key가 다르다면? 이 경우도 할당하는게 맞다고 생각하는가?
```
iex(16)> %{"key"=>variable} = %{"another key"=>"asdf"}
** (MatchError) no match of right hand side value: %{"another key" => "asdf"}
```
보는것처럼 key가 다른 맵끼리 할당하려고 하면 에러를 던진다. 어찌보면 이는 합리적인 처사라고 볼수있다. 왜냐? 그저 키가 달라도 할당할 수 있도록 프로그램을 설계했다고 가정해 보자.\
그런 경우에는 map에 원소가 하나가 아니라 둘인 경우에 어느 값을 어느 변수에 할당해야 할지 결정할 수 없다
```
iex(17)> %{"key1"=>v1, "key2"=>v2} = %{"key2"=>"key2value", "key1"=> "key1value"}
%{"key1" => "key1value", "key2" => "key2value"}
iex(18)> v1
"key1value"
iex(19)> v2
"key2value"
```
위의 예에는 2개의 키인 key1과 key2가 있다. 그런데 할당하는 쪽에서 key2와 key1의 순서를 뒤바꿨다. 이 경우 그저 key값이 어떤지에 상관없이 순서대로 할당한다고 가정하면 v1에 "key2value"가 할당되고 v2에 "key1value"가 할당된다. 이런 할당을 원하는 개발자는 거의 없을 것이다\
마지막으로 맵끼리의 할당시에는 맵을 구성하는 키가 완벽하게 동일할 필요는 없다. 할당받는 쪽이 할당하는 맵의 부분집합이기만 하면 된다. 즉 아래와 같은 상황이다
```
iex(20)> %{"key1"=>v1} = %{"key1"=>"1", "key2"=> "2"}                                
%{"key1" => "1", "key2" => "2"}
iex(21)> v1   
"1"
```

##### 패턴 매칭
결론부터 말하면 패턴 매칭을 함수호출에 적용하면  분기문을 없앨수 있다\
함수를 호출할 때 인자의 종류에 따라서 다른 함수를 호출해야 할 때가 있다\
가령 아래와 같은 자바스크립트 코드의 경우다
```
var 도형 = 도형구하기()
if(도형 instanceof 삼각형){
  삼각형넒이(도형)
} else if(도형 instanceeof 사각형){
  사각형넒이(도형)
}    
```
위의 코드는 도형이 삼각형 객체의 인스턴스일 때 `삼각형넒이`함수를 호출하고, 사각형 객체의 인스턴스일 때는 `사각형넒이` 함수를 호출한다. 인자의 종류에 따라서 다른 함수를 호출하는 흔한 패턴이다\
위의 코드는 패턴 매칭을 사용할 경우 아래 코드로 치환될 수 있다
```
var 도형 = 도형구하기()
넒이구하기(도형)
```
두말할 것 없이 코드가 간결해졌다. 물론 이것은 아직까지 자바스크립트에서 지원하는 기능은 아니다. 하지만 엘릭서에서는 가능하다\
어떻게 이것이 가능한가? 여러분은 아마도 함수 오버로딩이라는 개념을 들어봤을 것이다. 함수의 이름이 같고 인자의 갯수가 다를 때는 인자의 갯수에 맞추어 각기 다른 함수가 호출된다는 개념이다. 패턴 매칭도 이와 비슷한 개념이지만 한가지 중요한 차이점이 있다\
`패턴 매칭은 인자의 갯수가 같은 경우에 발동한다`\
인자의 갯수가 같은 경우에 인자의 패턴에 따라서 각기 다른 함수를 호출한다. 그래서 이름이 패턴 매칭이다.\
위의 코드에서는 각각 인자가 삼각형객체의 인스턴스인 케이스와, 인자가 사각형객체의 인스턴스인 경우를 별도로 정의해 놓아야 한다. 예를들어 아래와 같다
```
넒이구하기(삼각형) -> (삼각형.밑변 * 삼각형.높이) / 2
넒이구하기(사각형) -> (사각형.x * 사각형.y) 
```
위의 코드가 패턴매칭을 구현해놓은 코드이다. 각각의 라인별로 각기다른 패턴을 정의해놓은 것이고 `넒이구하기`라고 적혀진 함수이름은 헤드(head)라고 부른다. 괄호안의 인자는 패턴이라고 부른다. 마지막으로 화살표(`->`) 오른편은 함수의 바디(body)이며 실제로 함수가 실행되는 내용이다\
이와같이 정의해 놓으면 함수를 호출할 때 맨 위에 정의해놓은 패턴부터 차례대로 패턴에 해당되는지를 체크하고 맞으면 함수의 몸체를 실행한다. 패턴에 부합하지 않으면 다음 패턴을 체크한다. 이 과정을 모든 패턴에 대하여 수행한다. 이것은 그야말로 if-else문과 완전히 똑같은 흐름이다. 하지만 패턴매칭이 if-else문과 대비되는 점은 분기문을 실행흐름 중간에 삽입하지 않아도 되며 실행흐름과 떼어놓을 수 있다는 점이다. 그렇게 얻을 수 있는 결과는 if-else같은 지저분한 분기문을 제거할 수 있게 되고 그렇게 되어 코드가 더욱 깔끔하고 이해하기 쉬워진다는 점이다\
이제 구체적인 엘릭서의 패턴매칭 문법을 살펴보자. 위의 `넒이구하기` 패턴매칭을 엘릭서로 구현하면 아래와 같다
##### 이 코드는 준비중입니다

##### 파이프 연산자
파이프 연산자는 함수의 연속 호출을 편하게 해주는 기능이다. 가령 아래처럼 세금을 구하는 코드가 있다고 해보자
```
var 집정보 = 원하는집구하기()
var 공시지가 = 공시지가구하기(집정보)
var 세금 = 세금구하기(공시지가)
```
위의 코드는 함수를 호출하고 함수의 리턴값을 그 다음 함수에 인자로 넣는 흔한 패턴이다. 이 코드는 아무 문제가 없다. 그래 .. 문제는 없지만 더 나은 코드를 만들수는 있다. 가령 다음과 같은 방법으로 중간변수를 제거할 수 있다
```
var 세금 = 세금구하기(공시지가구하기(원하는집구하기()))
```
위의 코드는 집정보 변수와 공시지가 변수가 제거되었다. 그 결과 더 나은 코드가 되었다..고 말할 수 있는가? 변수는 적어졌지만 함수를 호출하는 순서를 알아보기 어렵게 되었다. 너무 보기 불편하므로 코드를 정리하면 조금 나아질까 ?
```
var 세금 = 세금구하기(
              공시지가구하기(
                원하는집구하기()
              )
           )
```
이렇게 정렬을 해놓으니 조금은 낫다. 그러나 이게 만족스러운가 ? 인간이 코드를 보는 자연스러운 순서는 위에서부터 아래이므로 눈에 들어오는 함수의 순서는 `세금구하기 -> 공시지가 구하기 -> 원하는집구하기`의 순서이다. 그러나 실제로 수행되는 함수의 순서는 정반대이다. 이것은 비직관적이며 코드의 가독성을 떨어뜨린다. 그래서 함수형 개발자들은 아예 새로운 문법을 만들어 냈다. 그 새로운 문법을 파이프라인 연산자라고 부른다. 위의 코드를 엘릭서의 파이프라인 연산자로 표기하면 아래와 같다
```
세금 = 원하는집구하기 
            |> 공시지가구하기
            |> 세금구하기
```
두말할 것 없이 코드가 간결해졌다. 위의 코드에서 삼각형 모양의 연산자 (`|>`)는 파이프라인 연산자라고 부른다. 이 연산자 앞에 있는 함수를 호출하여 나온 리턴값을 연산자 뒤에 나오는 함수에 인자로 집어넣는 방식이다. 이렇게 하면 리턴값을 변수에 담아두지 않고도 순차적으로 실행되는 함수의 흐름을 직관적으로 표현할 수 있다.\
이것을 응용하면 첫번째 함수를 호출할 때 인자가 들어가는 경우, 인자와 함수를 떼어내어 가독성을 더욱 높일 수 있다. 가령 아래와 같은 경우의 코드를 살펴보자
```
문자열 = "  i have trim space  "
수정된문자열 = String.trim(문자열)
              |> String.upcase
```
위의 코드는 파이프 연산자를 이용하면 아래와 같이 바꿀 수 있다
```
수정된문자열 = "  i have trim space  "
              |> String.trim
              |> String.upcase
```
위의 코드는 인자인 `"  i have trim space  "`가 어떤 함수를 거쳐 수정된 문자열을 리턴하는지 직관적으로 이해하기 쉽다\
\
여담이지만 위의 코드에서 소문자를 대문자로 바꿔주는 함수의 이름이 upcase이다. 다른 대부분의 언어에서는 이 함수의 이름이 uppercase인데 엘릭서에서 이름이 upcase인 이유는 타이핑을 한글자라도 덜 하게 하려고 만든 의도가 있다. 같은 이유로 리스트에서 중복된 요소를 제거하는 유니크 함수의 이름도 unique가 아니라 uniq이다\
\
파이프 연산자의 마지막 주제로, 중간에 호출되는 함수에서 2개 이상의 인자를 필요로하는 경우를 알아보자. 가령 다음과 같다
```
문자열  = "  i have trim space  "
트림된문자열 = String.trim(문자열)
분리된문자열 = String.split(트림된문자열, ",")
```
위의 예제에서 String.split는 2개의 인자를 가진다. 그런 split함수가 파이프라인 중간에 호출될 경우 인자를 어떻게 처리하게 되는가 ? 답은 간단한데 파이프 연산자의 결과물이 첫번째 인자에 들어가고 두번째 인자부터는 직접 채워줘야 한다. 즉 위의 코드를 파이프 연산자로 구현하면 다음과 같다
```
수정된문자열  =  "  i have trim space  " 
                |> String.trim
                |> String.split(",")
```
위의 코드는 정상작동한다. 그러나 이전에 이야기했듯이 함수 호출시에는 괄호를 제거할 수 있다고 했다. 위의 코드에서 split을 호출할 때 괄호를 제거해도 정상 작동할까 ? 가령 아래처럼 말이다
```
수정된문자열  =  "  i have trim space  " 
                |> String.trim
                |> String.split ","
```
물론 이 코드는 작동한다. 그러나 아래와 같은 경고 문구를 내뿜는다\
`warning: parentheses are required when piping into a function call` \
이것은 번역하면 아래와 같다\
`경고: 파이프로 함수를 호출할 때는 괄호를 사용하시오` \
이것은 의무는 아니지만 경고을 띄울 만큼 강력하게 권고되는 사양이다. 이것을 권장하는 이유는 단순하다. 괄호를 쓰지 않으면 문맥이 애매해져서 코드를 이해하기 어려워지기 때문(이라고 엘릭서의 창시자가 생각하기 때문)이다. 그의 의견에 동의할지 말지는 독자들의 자유다\
\
이쯤에서 예리한 독자의 반문이 있을 수 있다.\
`그러면 디버깅을 할 때 파이프라인의 어느 부분에서 에러가 발생하는지 찾기가 어려워지지 않는가?`\
이 말은 사실이다. 그래서 디버깅시에는 IO.inspect와 같은 프린트 함수를 중간에 삽입하여 중간 결과값을 보는 테크닉이 일반적이다. 가령 아래와 같다
```
수정된문자열  =  "  i have trim space  " 
                |> String.trim
                |> IO.inspect
                |> String.split ","
```
위의 코드는 중간에 IO.inspect를 만나면 아래의 문장을 출력한다\
`"i have trim space"`\
이것은 중간 결과값이고 이를 이용하면 파이프를 쓰지 않았을 때와 마찬가지의 디버깅 테크닉을 수행할 수 있다\
\
이것으로 파이프 연산자에 대한 소개는 끝이다. 파이프 연산자는 함수형 언어에서는 제법 흔한 개념이다. 사실 언어마다 파이프라인 연산자를 표기하는 방법은 조금씩 다르다. 이 삼각형 모양의 파이프라인 연산자 (`|>`)는 OCmal이라는 함수형 언어에서 기원을 두고 있으며 엘릭서에서 이 문법을 채용하여 쓰고 있다.

##### pin(`^`) 연산자
pin은 무언가를 고정할 때 쓰인다. 엘릭서에서도 마찬가지다. pin은 변수를 고정할 때 쓴다. 가령 변수에 값을 할당했다고 해보자\
`a = 1`\
위의 예에서 a에 다른값을 할당하고 싶으면 엘릭서에서는 그렇게 할 수 있다. 엘릭서는 재할당을 지원하기 때문이다. 가령 아래와 같다
```
a = 1
a = 2
```
위의 코드는 정상 작동한다. 그러나 핀(pin)을 사용하면 어떨까?. 핀을 사용하는 방법은 간단하다. 변수앞에 (`^`)를 붙여주면 된다. 위의 예에서 a변수에 핀을 적용하면 `^a`가 된다. 이것이 무슨 쓸모가 있을까? 아래의 예를 보자
```
a = 1
^a = 2
```
a에 변수를 할당한 상태에서 다른 값을 할당하려고 시도했다. 그러는 와중에 pin연산자를 사용했다. 이런 경우는 아래와 같은 에러 메시지를 띄운다\
`** (MatchError) no match of right hand side value: 2`\
번역하면 왼쪽 사이드에 `2`와 매칭되는 패턴이 없다는 뜻이다. 매칭 ? 그렇다. 사실 지금에서야 고백하는 말이지만 엘릭서에서는 변수에 값을 할당할 때도 패턴 매칭이 적용되서 왼쪽과 오른쪽의 패턴이 같은 상황에서만 할당을 허용하는 것이다. 리스트를 기반으로 변수를 할당하는 것도 패턴 매칭이었고 맵을 기반으로 변수에 할당할 때도 패턴 매칭이었다. 그런데 이상하지 않은가? `a = 2`처럼 특정한 자료구조 없이 그저 변수에 할당할 때는 지금까지 패턴 매칭을 수행하지 않은 것처럼 보였다. 그러나 사실 `a = 2`같은 단순한 할당문도 패턴 매칭을 수행한 것이다. 이것은 길이가 1인 리스트로 이해하면 직관적이다. 즉 `a = 2`를 `[a] = [2]`라고 이해하면 되겠다. 이것은 좌우의 패턴이 동일하므로 할당이 허용된다. 다만 `a에 pin연산자를 삽입했을 때는 패턴이 변한다`. 패턴매칭을 수행할 때 a의 값이 상수로 고정된다(값이 고정되서 이름이 pin이다). 즉 a에 1이 할당된 상황에서 `^a = 2`는 `[1] = [2]`라는 형태의 패턴 매칭이라고 해석할 수 있다. 당연한 말이지만 `[1]`은 `[2]`와 다르다. 패턴이 다르므로 에러가 난 것이다.